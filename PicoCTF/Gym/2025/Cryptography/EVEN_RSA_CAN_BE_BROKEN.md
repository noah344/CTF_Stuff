# EVEN RSA CAN BE BROKEN???
This was a challenge from PicoCTF 2025.  It's listed as easy and categorized as a Cryptography challenge.

## Description
The Description reads:
> This service provides you an encrypted flag.  
> Can you decrypt it with just N & e?

## Hints
There are three hints that read:
> How much do we trust randomness?  

> Notice anything interesting about N?  

and
> Try comparing N across multiple requests  

# Solving
## My Thoughts

## What is RSA?
RSA is an encryption algorithm that uses a public/private key pair to encrypt and decrypt data.  There's a lot of complicate crypto/math stuff in there if you want to look into it but we'll get to that!

## Connecting
Let's start off this challenge by trying to connect:

``` bash
└─$ nc verbal-sleep.picoctf.net 51624
N: 18660904008989614288702028542118399439508957206381923643238357178275164200291427226613287310450595233418169015061131532810235521783218622303006976736977254
e: 65537
cyphertext: 1992968696797035226582443064919403137231231011402192111506298313753367309391618207035231216653739374598752850660862384605144990544215579845650602716362183
```

Well that's certainly a lot to look at!  Let's try checking out the source code to see if we can get some context.

## Source Code

``` python
from sys import exit
from Crypto.Util.number import bytes_to_long, inverse
from setup import get_primes

e = 65537

def gen_key(k):
    """
    Generates RSA key with k bits
    """
    p,q = get_primes(k//2)
    N = p*q
    d = inverse(e, (p-1)*(q-1))

    return ((N,e), d)

def encrypt(pubkey, m):
    N,e = pubkey
    return pow(bytes_to_long(m.encode('utf-8')), e, N)

def main(flag):
    pubkey, _privkey = gen_key(1024)
    encrypted = encrypt(pubkey, flag) 
    return (pubkey[0], encrypted)

if __name__ == "__main__":
    flag = open('flag.txt', 'r').read()
    flag = flag.strip()
    N, cypher  = main(flag)
    print("N:", N)
    print("e:", e)
    print("cyphertext:", cypher)
    exit()
```

That's a lot to look at too! Let's comment it out a bit:

``` python
from sys import exit
from Crypto.Util.number import bytes_to_long, inverse
from setup import get_primes

# Initializes e with the integer 65537
e = 65537

def gen_key(k):
    """
    Generates RSA key with k bits
    """
    # Creates the p and q variables by calling the get_primes function from the setup module above.
    # We don't have the source code for get_primes but we can assume that it...gets primes, presumably from the number sent into it.
    # Since it's only ever sent in 1024//2 (which equals 512).
    # Based on how RSA works, get_primes likely returns two very large prime numbers that are 512 bits in size.
    p,q = get_primes(k//2)
    # N is then generated by multiplying the two above primes together, this is one of the values we are given when connecting to the server.
    N = p*q
    # d (this is the private key) is then generated, this is all based on how RSA works which you can lookup but i'll explain best I can.
    # p and q, their values reduced by 1, are first multipled.
    # the values of e and p*q are then sent to the inverse function which 'finds the modular inverse of the two numbers'
    # Wel that means it finds e * x = y such that y % (p-1)*(q-1) = 1.  That's complicated so let's keep going.
    d = inverse(e, (p-1)*(q-1))

    # A tuple holding N and e (public key) is sent back along with d (private key)
    return ((N,e), d)

def encrypt(pubkey, m):
    # Pulls N and e from the pubkey tuple
    N,e = pubkey
    
    # this form of pow, pow(x, y, z) will return (x^y) % z
    # m (our flag) will convert the string into bytes, which will then be converted into an integer.
    # so pow is fed pow(integerified(flag), e, N) so the formula will be (integerified(flag)^65537) % N
    # Notice that we know both z and y!
    return pow(bytes_to_long(m.encode('utf-8')), e, N)

def main(flag):
    # Initializes pubkey and privkey by calling the gen_key function
    pubkey, _privkey = gen_key(1024)
    # Initializes the encrypted text by calling the encrypt function.
    encrypted = encrypt(pubkey, flag) 
    # Returns N from pubkey, and the encrypted text
    return (pubkey[0], encrypted)

if __name__ == "__main__":
    flag = open('flag.txt', 'r').read()
    flag = flag.strip()
    N, cypher  = main(flag)
    print("N:", N)
    print("e:", e)
    print("cyphertext:", cypher)
    exit()
```

Again, that's a lot to look at.  Bottomline, there's nothing inherently insecure in what we can see! With that in mind, we have to assume that there's an issue with the get_primes function somehow.  One of the major weaknesses with RSA is when the p and q variables are too easy to discern.

Let's take one of our N values and plug it into factordb.com and see what we get:

![FactorDB](https://github.com/user-attachments/assets/ac12143c-af1f-462a-8fdb-97aa091a06b6)

Oh! Looks like N is generated by one very long and complex prime, and another very very short factor: 2.  RSA is ONLY secure when both p and q are very large primes because of the amount of computing time it takes to calculate primes.  If either p or q are short or easily guessable, the entire algorithm falls apart.

We can effectively calculate both p and q each time we run the program now and with that we can decrypt our flag!

Let's take our output from above and get the flag:

> N = 18660904008989614288702028542118399439508957206381923643238357178275164200291427226613287310450595233418169015061131532810235521783218622303006976736977254  
> p = 2  
> q = 18660904008989614288702028542118399439508957206381923643238357178275164200291427226613287310450595233418169015061131532810235521783218622303006976736977254 / 2 = 9330452004494807144351014271059199719754478603190961821619178589137582100145713613306643655225297616709084507530565766405117760891609311151503488368488627  
> d = inverse(65537, (p - 1 = 1)*(q-1))  
> d = 1324176176721641229375906491525727704860405656167953002164883654387119506743599528775578568400300488777502708463032976690022434564488124311764864814002971  

Nice, so we now have the private key! Now we just need to decrypt the flag:

> pow(cipher, d, N) = 3030612722376619015339251852200174143198160267119207878925874759940477  
> Convert the above to bytes, then to utf-8: picoCTF{tw0_1$_pr!m378257f39}

Cool! Let's automate it:

``` python
from pwn import *
from Crypto.Util.number import inverse, long_to_bytes

# Connect to remote server
r = remote("verbal-sleep.picoctf.net", 51624)

# Grab N
r.recvuntil(b'N: ')
N = int(r.recvline())
# Grab e
r.recvuntil(b'e: ')
e = int(r.recvline())
# Grab cypher
r.recvuntil(b'cyphertext: ')
cypher = int(r.recvline())

# We already know p will always be 2
p = 2
# Calculate q, the // is necessary to make sure python doesn't guesstimate
q = int(N // 2)
# Calculate d
d = inverse(e, (p-1)*(q-1))
# Decrypt the flag
dec = pow(cypher, d, N)
# Convert int to bytes
plain_bytes_dec = long_to_bytes(dec)
# Convert bytes to plaintext
plain_dec = plain_bytes_dec.decode()

print("N: %s" % N)
print("e: %s" % e)
print("Cypher: %s" % cypher)
print("p: %s" % p)
print("q: %s" % q)
print("d: %s" % d)
print("Flag: %s" % plain_dec)
```

With this script we get some really nice quick output!
