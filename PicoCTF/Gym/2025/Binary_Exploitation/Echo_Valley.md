# Echo Valley
This was a challenge listed in PicoCTF 2025.  It's listed as Medium and categorized as a Binary Exploitation challenge.

## Description
The Description reads:
> The echo valley is a simple function that echoes back whatever you say to it.  
> But how do you make it respond with something more interesting, like a flag?

## Hints
There is a single hint that reads:
> Ever heard of a format string attack?

# Solving
## My Thoughts
This was the first of the challenges that I ended up solving after the CTF ended, I got a little sick of binary exploitation challenges during the actual event and instead banged my head against the CHACHA one for hours.  We'll see how it goes!

## Source Code
Before even jumping into the program, let's take a quick look at the source code, I've added comments to improve readability:

``` c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Prints the flag...duh.
void print_flag() {
    // Initiates a string variable named buf that will hold up to 32 bytes of data.
    char buf[32];

    // fopen will open a file pointer to the /home/valley/flag.txt file in read only mode.
    FILE *file = fopen("/home/valley/flag.txt", "r");

    // Makes sure the file actually exists
    if (file == NULL) {
      perror("Failed to open flag file");
      exit(EXIT_FAILURE);
    }
    
    // Uses the fgets function to read in data from the file (up to the size of buf), storing the data in buf.
    fgets(buf, sizeof(buf), file);
    // Prints the data in buf.
    printf("Congrats! Here is your flag: %s", buf);
    // Closes the file.
    fclose(file);
    // Exits out of the program.
    exit(EXIT_SUCCESS);
}

// This function is responsible for most of what actually happens and where our vulnerable code sits.
void echo_valley() {
    printf("Welcome to the Echo Valley, Try Shouting: \n");

    // Initiates a string variable named buf that can hold up to 100 bytes.
    char buf[100];

    // Essentially will loop forever since 1 evaluates to True.
    while(1)
    {
        // Flushes the output buffer of the stdout stream, 
        // it makes sure any buffered data is written to the 
        // file/device associated with the stream.
        fflush(stdout);
        // Reads in up to 100 bytes of user input and stores it in buf.
        // Also checks to make sure the user actually entered something,
        // If they didn't, the program exits.
        if (fgets(buf, sizeof(buf), stdin) == NULL) {
          printf("\nEOF detected. Exiting...\n");
          exit(0);
        }

        // Checks if the user entered the string 'exit' exactly.
        // If they did, it prints the below string and ends the while loop.
        if (strcmp(buf, "exit\n") == 0) {
            printf("The Valley Disappears\n");
            break;
        }

        // Prints out the user's input and flushes stdout like it did above.
        printf("You heard in the distance: ");
        printf(buf);
        fflush(stdout);
    }
    // Once the while loop is exited, the stdout stream is flushed.
    fflush(stdout);
}

// The main function, where everything else starts.
int main()
{
    // Calls the echo_valley function with no variables.
    echo_valley();
    // Returns 0 if the prgoram runs through without issues.
    return 0;
}

```

Now, there are really only a few functions in the script, let's look at each below:

- fflush:  This function is only really dangerous if it's used with an input stream.  It's only ever used with stdout in this program which means it's not dangerous or exploitable (at least not directly).
- fgets:  This function on it's own is not dangerous, but it combined with unsanitized input and the below function does make it problematic!
- printf:  This function allows us to send in format strings, allowing us to do all sorts of nasty things.
-
- Let's see what we can do with that, but first lets check out the executable.

## Executable
Let's run file on it to see what we're working with:

``` bash
└─$ file valley
valley: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=389c2641f0d3caae81af5d21d9bb5bcf2de217f0, for GNU/Linux 3.2.0, with debug_info, not stripped
```

So, we're working with a 64-bit LSB (least significant bit), PIE executable.  Running strings doesn't give us anything crazy, let's try running it now and see what we can do.

## Running It
Well we can definitely see that there is a string format vulnerability:

![String Format Vulnerability](https://github.com/user-attachments/assets/c60b3759-65ec-434d-8dee-479470975f9b)

Let's run it through GDB and get the memory addresses of the various functions:

``` bash
─
pwndbg> print main
$1 = {int ()} 0x555555555401 <main>
pwndbg> print print_flag
$2 = {void ()} 0x555555555269 <print_flag>
pwndbg> print echo_valley
$3 = {void ()} 0x555555555307 <echo_valley>
```

We can also see that the values above are based on the starting address below:

![Starting Address](https://github.com/user-attachments/assets/f25f776c-8430-4a51-975d-6799904a4622)

Now let's setup a quick script and run through a bunch of string format values to see if we can get a leak, it's important to note that gdb disables ASLR so we'll need to do the same in our script to mirror GDB as much as possible:


